export const dockerTheory = [
  {
    time: '00:00',
    title: 'Введение в контейнеризацию',
    content: `Docker — это платформа для разработки, доставки и запуска приложений в контейнерах. Многие считают Docker сложным, но понимание основ Linux делает его простым для освоения.

Контейнеры позволяют упаковать приложение со всеми зависимостями (библиотеки, конфигурации, runtime) в изолированное окружение, которое можно запустить на любой системе с Docker. Это решает проблему "у меня на машине работает" — контейнер работает одинаково везде.`,
  },
  {
    time: '00:59',
    title: 'Что такое контейнер?',
    content: `Контейнеры в Linux — это абстракция, а не реальные физические объекты. По сути, контейнер — это изолированный процесс в операционной системе Linux со специальными ограничениями.

Изоляция достигается с помощью встроенных механизмов ядра Linux: namespaces (для изоляции ресурсов) и cgroups (для ограничения ресурсов). Контейнер использует ядро хостовой системы, в отличие от виртуальных машин, которые эмулируют полноценную ОС с собственным ядром. Это делает контейнеры намного легковеснее и быстрее.`,
  },
  {
    time: '01:58',
    title: 'Системный вызов chroot',
    content: `chroot — древний метод изоляции, появившийся ещё в Unix в 1979 году. Он позволяет изменить корневой каталог для процесса и его потомков, создавая иллюзию отдельной файловой системы.

Когда процесс запущен в chroot-окружении, он не видит файлы за пределами назначенного каталога. Путь "/" указывает на новый корень, а не на реальный корень системы. chroot — это первый шаг к созданию изолированного окружения, но он изолирует только файловую систему.`,
  },
  {
    time: '02:44',
    title: 'Практический пример с chroot',
    content: `Чтобы создать простое chroot-окружение: создаём директорию, копируем в неё необходимые исполняемые файлы (например, /bin/bash), копируем все библиотеки, от которых зависит исполняемый файл (можно найти через ldd), затем выполняем chroot с указанием нового корневого каталога.

После выполнения chroot процесс видит только содержимое нового корневого каталога. Однако это несовершенная изоляция — процессы, сеть, пользователи и другие системные ресурсы остаются общими с хостовой системой.`,
  },
  {
    time: '04:51',
    title: 'Ограничения chroot',
    content: `chroot изолирует только файловую систему, но не процессы. Процессы в chroot-окружении видят все процессы хостовой системы через /proc. chroot не изолирует сеть — процесс может свободно открывать сетевые соединения и портыОн также не изолирует пользователей, IPC (межпроцессное взаимодействие) и другие ресурсы.

Для полной изоляции, необходимой для контейнеров, нужны дополнительные механизмы — пространства имён (namespaces).`,
  },
  {
    time: '06:50',
    title: 'Пространства имён (Namespaces)',
    content: `Namespaces — это механизм ядра Linux для изоляции системных ресурсов. Процессы в разных namespaces видят разные представления системных ресурсов, как будто работают на разных машинах.

Типы namespaces:
- **PID**: изоляция процессов (каждый namespace имеет свою нумерацию PID)
- **NET**: изоляция сети (свой сетевой стек, интерфейсы, правила файрвола)
- **MNT**: изоляция точек монтирования файловых систем
- **UTS**: изоляция hostname и domain name
- **IPC**: изоляция System V IPC и POSIX очередей сообщений
- **USER**: изоляция пользователей и групп

Процессы-потомки наследуют namespaces родителя, если явно не создаются новые. Утилита unshare позволяет создавать новые namespaces.`,
  },
  {
    time: '09:05',
    title: 'Создание изолированного контейнера с unshare',
    content: `Утилита unshare позволяет запускать процессы в новых namespaces. Комбинируя unshare с chroot, мы создаём изолированное окружение, близкое к контейнеру.

Например: unshare --pid --fork --mount-proc chroot /my-container /bin/bash

Эта команда создаёт новый PID namespace, делает fork процесса, монтирует /proc внутри контейнера и выполняет chroot. В результате процесс видит только себя в списке процессов (ps покажет только bash) и имеет изолированную файловую систему.`,
  },
  {
    time: '10:05',
    title: 'Контрольные группы (cgroups)',
    content: `cgroups (control groups) — механизм ядра Linux для ограничения, учёта и изоляции использования ресурсов группами процессов.

cgroups позволяют ограничивать:
- **CPU**: процентное использование или конкретные ядра
- **Память**: максимальный объём RAM и swap
- **Дисковый I/O**: скорость чтения/записи
- **Сеть**: пропускная способность

Без cgroups процесс мог бы потребить все ресурсы системы, заблокировав другие контейнеры или хостовую систему. cgroups критически важны для безопасной работы множества контейнеров на одном хосте.`,
  },
  {
    time: '12:46',
    title: 'Практика с cgroups',
    content: `Создадим контрольную группу с ограничением памяти:

mkdir /sys/fs/cgroup/memory/my-container
echo 100M > /sys/fs/cgroup/memory/my-container/memory.limit_in_bytes

Теперь запустим процесс, который пытается потребить много памяти, и добавим его в эту cgroup. Когда процесс превысит лимит в 100 МБ, механизм OOM Killer ядра Linux принудительно завершит процесс.

Логи ядра (dmesg) покажут, что процесс был остановлен из-за превышения лимита памяти. Это защищает систему от исчерпания ресурсов одним "жадным" процессом.`,
  },
  {
    time: '14:09',
    title: 'Контейнеры как изолированное окружение',
    content: `Теперь у нас есть все компоненты контейнера:
**Контейнер = процесс + namespaces (изоляция) + cgroups (ограничения ресурсов) + chroot (изолированная ФС)**

Контейнеризация — это вид виртуализации на уровне операционной системы. Контейнеры легковеснее виртуальных машин, так как используют общее ядро хостовой ОС, не эмулируя аппаратное обеспечение.

Системы управления контейнерами (Docker, containerd, CRI-O) автоматизируют создание и настройку namespaces, cgroups и файловой системы, предоставляя удобный интерфейс для работы с контейнерами.`,
  },
  {
    time: '15:28',
    title: 'Низкоуровневый runtime: runc',
    content: `runc — низкоуровневый инструмент для запуска контейнеров, реализующий спецификацию OCI (Open Container Initiative). Docker использует runc под капотом для фактического запуска контейнеров.

runc принимает на вход спецификацию контейнера (JSON-файл config.json) и создаёт:
- Необходимые namespaces для изоляции
- cgroups с заданными лимитами ресурсов
- Изолированную файловую систему
- Запускает указанный процесс с нужными параметрами

runc — это "мотор" контейнеризации. Docker добавляет поверх него управление образами, сетью, томами и удобный API.`,
  },
  {
    time: '15:28',
    title: 'Создание контейнера с runc',
    content: `Создадим контейнер с помощью runc:

mkdir my-container
cd my-container
runc spec

Команда runc spec генерирует файл config.json — спецификацию контейнера. Она содержит:
- Версию OCI спецификации
- Параметры процесса (команда для запуска, аргументы, переменные окружения)
- Пользователя, от имени которого запускается процесс
- Путь к корневой файловой системе (rootfs)
- Настройки namespaces и cgroups
- Монтируемые файловые системы

Эта конфигурация полностью описывает окружение контейнера.`,
  },
  {
    time: '17:25',
    title: 'Структура Docker-образов',
    content: `Docker-образ — это набор слоёв файловой системы, наложенных друг на друга. Каждый слой представляет изменения относительно предыдущего: добавление, изменение или удаление файлов.

Слои используют технологию copy-on-write (CoW) для эффективного использования дискового пространства. Если несколько контейнеров используют один базовый образ, этот образ хранится на диске один раз, экономя место.

Контейнер = образ (read-only слои) + изменяемый верхний слой (контейнерный слой).

Все изменения, сделанные в контейнере, записываются в верхний слой. При удалении контейнера этот слой удаляется, а базовые слои образа остаются нетронутыми.

Образы можно скачать с Docker Hub или создать самостоятельно с помощью Dockerfile.`,
  },
  {
    time: '17:25',
    title: 'Запуск контейнера с runc',
    content: `После настройки rootfs (корневой файловой системы) и config.json, запускаем контейнер:

runc run my-container

runc создаёт все необходимые namespaces и cgroups, настраивает файловую систему и запускает указанный в config.json процесс (обычно /bin/sh или /bin/bash).

Внутри контейнера видна только изолированная файловая система из rootfs. Стандартные Linux программы (ls, cat, ps) доступны, если они были включены в rootfs.

Это полноценный контейнер, созданный с помощью низкоуровневых инструментов. Docker делает то же самое, но автоматизирует весь процесс.`,
  },
  {
    time: '19:35',
    title: 'Заключение',
    content: `Понимание внутренних механизмов Docker критически важно для DevOps-инженеров. Оно помогает:
- Отлаживать проблемы с контейнерами
- Оптимизировать производительность
- Обеспечивать безопасность
- Понимать ограничения и возможности контейнеризации

Основа контейнеров: chroot (изоляция ФС) + namespaces (изоляция ресурсов) + cgroups (ограничения).

Docker абстрагирует эту сложность, предоставляя удобный интерфейс, но под капотом работают именно эти механизмы ядра Linux. Знание основ помогает в отладке и оптимизации контейнерных приложений. Изучение runc и OCI расширяет понимание экосистемы контейнеров и альтернативных реализаций (containerd, CRI-O, Podman).`,
  },
]

