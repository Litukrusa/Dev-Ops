export const tcpTheory = [
  {
    time: '00:00',
    title: 'История создания интернета',
    content: `В 1970-х годах научные и исследовательские институты США и Европы начали создавать локальные компьютерные сети для обмена данными между исследователями. Каждая организация разрабатывала свои собственные протоколы и правила передачи данных, что привело к проблеме несовместимости.

Возникла необходимость объединить эти разрозненные сети в единую глобальную сеть — интернет. Основная проблема заключалась в том, что разные сети использовали разные способы упаковки и передачи данных, разные адреса и форматы сообщений.

Для решения этой проблемы нужна была универсальная система правил — стек протоколов, который бы позволил разным сетям общаться друг с другом независимо от их внутренней реализации.`,
  },
  {
    time: '00:58',
    title: 'Модель OSI',
    content: `В 1983 году Международная организация по стандартизации (ISO) представила модель OSI (Open Systems Interconnection) — концептуальную модель для понимания и проектирования сетей. Модель OSI делит сетевое взаимодействие на 7 уровней:

**Физический уровень (Layer 1)**: передача битов по физической среде (кабели, радиоволны)

**Канальный уровень (Layer 2)**: передача данных между соседними узлами, обнаружение ошибок (Ethernet, Wi-Fi)

**Сетевой уровень (Layer 3)**: маршрутизация пакетов через сеть (IP)

**Транспортный уровень (Layer 4)**: надежная доставка данных между приложениями (TCP, UDP)

**Сеансовый уровень (Layer 5)**: управление сеансами связи

**Уровень представления (Layer 6)**: форматирование и шифрование данных

**Прикладной уровень (Layer 7)**: взаимодействие с приложениями (HTTP, FTP, DNS)

Каждый уровень добавляет свой заголовок к данным при отправке и удаляет его при получении. Этот процесс называется инкапсуляцией.`,
  },
  {
    time: '01:50',
    title: 'Модель TCP/IP',
    content: `Модель TCP/IP упростила 7-уровневую модель OSI до 4 уровней, объединив верхние уровни. Это практическая модель, которая описывает реальную работу интернета:

**Канальный уровень**: объединяет физический и канальный уровни OSI. Отвечает за передачу данных в локальной сети.

**Межсетевой уровень (Internet Layer)**: соответствует сетевому уровню OSI. Протокол IP отвечает за адресацию и маршрутизацию пакетов через множество сетей.

**Транспортный уровень**: протоколы TCP и UDP обеспечивают доставку данных между приложениями на разных компьютерах.

**Прикладной уровень**: объединяет сеансовый, представления и прикладной уровни OSI. Здесь работают протоколы HTTP, FTP, SMTP, DNS и др.

Модель TCP/IP не просто описывает уровни, но и жестко определяет протоколы для каждого уровня, что обеспечило совместимость всех устройств в интернете.`,
  },
  {
    time: '02:45',
    title: 'Прикладной уровень и его задачи',
    content: `Прикладной уровень — это самый верхний уровень модели TCP/IP, где работают пользовательские приложения и сервисы. Он решает несколько критических задач:

**Управление сеансами**: установка, поддержание и завершение соединений между приложениями. Например, при загрузке веб-страницы браузер открывает несколько параллельных соединений для загрузки разных ресурсов.

**Представление данных**: преобразование данных в формат, понятный обеим сторонам. Это включает кодировку текста (UTF-8, ASCII), сжатие данных (gzip, br) и шифрование (TLS).

**Синхронизация**: координация потоков данных, чтобы получатель мог правильно собрать и обработать информацию даже если она приходит частями или с задержками.

На этом уровне работают протоколы: HTTP (веб), SMTP (почта), FTP (файлы), DNS (имена), SSH (удаленный доступ) и многие другие. Каждый протокол определяет свой формат сообщений и правила взаимодействия.`,
  },
  {
    time: '05:47',
    title: 'Протоколы и заголовки',
    content: `Протокол — это формализованный набор правил для обмена данными. Каждый протокол определяет структуру сообщений, типы запросов, коды ошибок и порядок взаимодействия.

Ключевой концепцией является **заголовок** (header) — структурированная мета-информация, которая добавляется к данным на каждом уровне. Заголовок содержит служебную информацию:
- Адреса отправителя и получателя
- Тип передаваемых данных
- Размер сообщения
- Контрольные суммы для проверки целостности
- Флаги управления

Например, HTTP-заголовок может содержать: тип контента (application/json), метод (GET/POST), путь (/api/users), версию протокола (HTTP/1.1), cookies для аутентификации и многое другое.

Процесс инкапсуляции: данные приложения + HTTP заголовок = HTTP сообщение. Затем добавляется TCP заголовок, затем IP заголовок, затем Ethernet заголовок. При получении происходит обратный процесс — декапсуляция.`,
  },
  {
    time: '06:43',
    title: 'Порты и адресация процессов',
    content: `Порт — это 16-битное число (0-65535), которое идентифицирует конкретный процесс или сервис на компьютере. IP-адрес определяет компьютер в сети, а порт — приложение на этом компьютере.

**Диапазоны портов:**

**Системные (0-1023)**: зарезервированы для стандартных служб. Требуют прав администратора.
- 20, 21: FTP
- 22: SSH
- 25: SMTP (почта)
- 53: DNS
- 80: HTTP
- 443: HTTPS

**Зарегистрированные (1024-49151)**: для известных приложений
- 3306: MySQL
- 5432: PostgreSQL
- 6379: Redis
- 8080: альтернативный HTTP

**Динамические (49152-65535)**: временные порты, назначаемые ОС для исходящих соединений.

Полный сетевой адрес называется **socket** и имеет формат IP:порт, например 192.168.1.1:8080. Транспортный уровень использует порты для мультиплексирования — одновременной работы множества приложений на одном компьютере.`,
  },
  {
    time: '08:17',
    title: 'Протокол TCP: основы',
    content: `TCP (Transmission Control Protocol) — это протокол транспортного уровня, обеспечивающий надежную, упорядоченную доставку потока байтов между приложениями.

**Основные характеристики TCP:**

**Connection-oriented**: перед передачей данных устанавливается соединение (three-way handshake)

**Надежность**: гарантирует доставку всех данных в правильном порядке

**Контроль ошибок**: обнаруживает поврежденные пакеты и запрашивает повторную передачу

**Контроль потока**: адаптирует скорость передачи к возможностям получателя

**Контроль перегрузки**: адаптирует скорость к состоянию сети

TCP разбивает данные на **сегменты** — части сообщения, которые помещаются в IP-пакеты. Каждый сегмент получает порядковый номер, что позволяет получателю собрать данные в правильном порядке, даже если сегменты приходят вразнобой.

TCP используется для: HTTP/HTTPS, FTP, SSH, электронной почты — всех протоколов, где критична надежность доставки.`,
  },
  {
    time: '09:36',
    title: 'Механизм гарантии доставки',
    content: `TCP обеспечивает надежность через механизм подтверждения (acknowledgment) и повторной передачи:

**1. Нумерация байтов**: каждый байт в потоке данных имеет уникальный порядковый номер (sequence number). Это позволяет отслеживать, какие данные были переданы.

**2. Подтверждение (ACK)**: получатель отправляет ACK-пакет с номером следующего ожидаемого байта. Например, если получены байты 1-1000, ACK будет содержать 1001.

**3. Таймер повторной передачи (RTO)**: отправитель запускает таймер после отправки сегмента. Если ACK не приходит до истечения таймера, сегмент отправляется заново.

**4. Обнаружение дубликатов**: благодаря порядковым номерам, получатель может определить дублированные сегменты и отбросить их.

**5. Упорядочивание**: даже если сегменты приходят не по порядку, получатель может правильно собрать данные, используя порядковые номера.

Этот механизм гарантирует, что даже в нестабильной сети с потерями пакетов, данные будут доставлены полностью и корректно.`,
  },
  {
    time: '10:29',
    title: 'Контроль потока: скользящее окно',
    content: `Контроль потока предотвращает ситуацию, когда быстрый отправитель переполняет медленного получателя данными.

**Буфер приема**: операционная система выделяет буфер (например, 64 КБ) для хранения входящих данных до того, как приложение их обработает.

**Размер окна (Window Size)**: получатель в каждом ACK указывает, сколько свободного места осталось в буфере. Это число называется "окно приема" (receive window).

**Адаптация скорости**: отправитель не может отправить больше данных, чем указано в окне приема. Если окно = 0 (буфер заполнен), отправитель приостанавливает передачу.

**Обновление окна**: когда приложение получателя читает данные из буфера, освобождается место, и получатель отправляет ACK с обновленным размером окна.

Пример: буфер 64 КБ, в нём 50 КБ данных. Окно = 14 КБ. Отправитель может послать максимум 14 КБ, затем должен ждать ACK с обновленным окном.

Этот механизм называется **скользящее окно** (sliding window) — граница того, что можно отправить, "скользит" по мере подтверждения данных.`,
  },
  {
    time: '11:26',
    title: 'Контрольная сумма и флаги TCP',
    content: `**Контрольная сумма (Checksum)**: 16-битное значение, вычисляемое по содержимому заголовка и данных. Получатель пересчитывает контрольную сумму и сравнивает с полученной. Несовпадение означает повреждение данных при передаче.

**Флаги TCP** — это 9 битов в заголовке, управляющих поведением протокола:

**SYN (Synchronize)**: запрос на установку соединения. Используется в three-way handshake.

**ACK (Acknowledgment)**: подтверждение получения данных. Присутствует почти во всех пакетах после установки соединения.

**FIN (Finish)**: запрос на корректное завершение соединения. Обе стороны должны обменяться FIN и ACK.

**RST (Reset)**: экстренный разрыв соединения при ошибке или атаке.

**PSH (Push)**: просьба немедленно передать данные приложению, не буферизуя.

**URG (Urgent)**: указывает на срочные данные, которые нужно обработать приоритетно.

Комбинации флагов определяют тип и назначение TCP-сегмента. Например, SYN без ACK = запрос на соединение, SYN+ACK = ответ на запрос соединения.`,
  },
  {
    time: '12:16',
    title: 'Three-Way Handshake',
    content: `Установка TCP-соединения происходит через процесс Three-Way Handshake (трёхэтапное рукопожатие):

**Шаг 1 (SYN)**: Клиент отправляет SYN-пакет с начальным порядковым номером (ISN — Initial Sequence Number), случайным числом для безопасности.
Пример: SYN, Seq=1000

**Шаг 2 (SYN-ACK)**: Сервер отвечает SYN-ACK, подтверждая получение (ACK=1001) и отправляя свой ISN.
Пример: SYN-ACK, Seq=5000, ACK=1001

**Шаг 3 (ACK)**: Клиент подтверждает получение SYN-ACK сервера.
Пример: ACK, Seq=1001, ACK=5001

После этого соединение установлено, и стороны могут обмениваться данными.

**Разрыв соединения (Four-Way Handshake)**:
1. Сторона A: FIN
2. Сторона B: ACK
3. Сторона B: FIN
4. Сторона A: ACK

Экстренный разрыв: отправка RST немедленно закрывает соединение без процедуры FIN.`,
  },
  {
    time: '13:04',
    title: 'Перегрузка сети',
    content: `Перегрузка (congestion) возникает, когда в сети больше трафика, чем она может обработать. Маршрутизаторы начинают отбрасывать пакеты, появляются задержки.

**Признаки перегрузки:**
- Потеря пакетов (таймауты повторной передачи)
- Увеличение RTT (Round-Trip Time)
- Explicit Congestion Notification (ECN) — маршрутизатор устанавливает специальный бит в IP-заголовке

**Проблема**: отправитель не знает о перегрузке и продолжает отправлять данные с высокой скоростью, усугубляя проблему.

**Решение**: TCP реализует алгоритмы контроля перегрузки, которые адаптивно уменьшают скорость передачи при обнаружении признаков перегрузки.

Важное отличие от контроля потока: контроль потока защищает получателя от переполнения, контроль перегрузки защищает сеть от коллапса.`,
  },
  {
    time: '15:02',
    title: 'Окно перегрузки (CWND)',
    content: `Окно перегрузки (Congestion Window, CWND) — это лимит на количество неподтвержденных данных в сети, который устанавливает отправитель на основе оценки состояния сети.

**Фазы работы TCP Congestion Control:**

**1. Slow Start (Медленный старт)**:
- CWND начинается с 1-10 MSS (Maximum Segment Size)
- При каждом полученном ACK CWND удваивается (экспоненциальный рост)
- Продолжается до достижения порога (ssthresh) или обнаружения потери

**2. Congestion Avoidance (Предотвращение перегрузки)**:
- После превышения ssthresh рост замедляется до линейного
- CWND увеличивается на 1 MSS за каждый RTT
- Это осторожное исследование доступной пропускной способности

**3. Fast Recovery (Быстрое восстановление)**:
- При обнаружении потери (3 дублированных ACK) CWND уменьшается вдвое
- ssthresh устанавливается в новое значение CWND
- Алгоритм быстро восстанавливается без возврата к Slow Start

Эти механизмы позволяют TCP эффективно использовать доступную пропускную способность, не перегружая сеть.`,
  },
  {
    time: '15:57',
    title: 'Структура TCP заголовка',
    content: `TCP-заголовок имеет минимальный размер 20 байт и может содержать до 40 байт опций.

**Обязательные поля:**
- Source Port (16 бит): порт отправителя
- Destination Port (16 бит): порт получателя
- Sequence Number (32 бита): номер первого байта данных в сегменте
- Acknowledgment Number (32 бита): номер следующего ожидаемого байта
- Data Offset (4 бита): длина заголовка в 32-битных словах
- Flags (9 битов): SYN, ACK, FIN, RST, PSH, URG и др.
- Window Size (16 бит): размер окна приема
- Checksum (16 бит): контрольная сумма
- Urgent Pointer (16 бит): указатель на срочные данные

**Опциональные поля (Options):**
- **MSS (Maximum Segment Size)**: максимальный размер сегмента, который может принять сторона
- **Window Scale**: множитель для масштабирования окна (для высокоскоростных сетей)
- **SACK (Selective Acknowledgment)**: выборочное подтверждение, позволяет подтвердить не непрерывные блоки данных
- **Timestamps**: временные метки для более точного измерения RTT

Поле Data Offset указывает, где начинаются данные, так как длина заголовка переменная из-за опций.`,
  },
  {
    time: '16:57',
    title: 'Протокол UDP',
    content: `UDP (User Datagram Protocol) — это простой протокол транспортного уровня без установки соединения и гарантий доставки.

**Характеристики UDP:**
- **Без соединения**: не требуется handshake перед отправкой данных
- **Без гарантий**: данные могут потеряться, дублироваться или прийти не по порядку
- **Быстрый**: минимальные накладные расходы
- **Датаграммы**: каждое сообщение независимо

**Заголовок UDP (всего 8 байт):**
- Source Port (16 бит)
- Destination Port (16 бит)
- Length (16 бит): длина датаграммы с заголовком
- Checksum (16 бит): опциональная в IPv4, обязательная в IPv6

**Когда использовать UDP:**
- Видео/аудио стриминг: потеря пары кадров не критична
- Онлайн игры: важнее низкая задержка, чем надежность
- DNS-запросы: короткие запросы, проще переспросить
- VoIP (голосовая связь)
- IoT устройства с простыми сообщениями

**Когда использовать TCP:**
- Веб-страницы, API
- Передача файлов
- Email
- Все, где важна целостность данных

Некоторые приложения реализуют собственную надежность поверх UDP для оптимального баланса скорости и надежности (например, QUIC).`,
  },
  {
    time: '17:42',
    title: 'DNS через UDP',
    content: `DNS (Domain Name System) использует UDP для большинства запросов. Это классический пример эффективного применения UDP.

**Процесс DNS-запроса:**
1. Приложение запрашивает IP-адрес домена (например, google.com)
2. Клиент отправляет UDP-датаграмму на порт 53 DNS-сервера
3. DNS-сервер ищет адрес и отправляет UDP-ответ
4. Если ответ не пришел за тайм-аут (обычно 5 секунд), клиент повторяет запрос
5. После 3-5 попыток клиент может попробовать другой DNS-сервер

**Почему UDP для DNS:**
- Запросы короткие (обычно < 512 байт), помещаются в одну датаграмму
- Установка TCP-соединения заняла бы больше времени, чем весь DNS-запрос
- Если запрос потерялся, проще отправить новый, чем восстанавливать TCP-соединение
- DNS-серверы обрабатывают миллионы запросов, экономия ресурсов критична

**Исключение**: Для больших ответов (>512 байт) или зонных трансферов DNS использует TCP.

Современное расширение EDNS0 позволяет увеличить размер UDP-датаграмм до 4096 байт, сохраняя преимущества UDP.`,
  },
  {
    time: '19:24',
    title: 'IP-адресация и маршрутизация',
    content: `IP (Internet Protocol) — протокол межсетевого уровня, отвечающий за адресацию и маршрутизацию пакетов через множество сетей.

**IPv4 адрес**: 32-битное число, записываемое как 4 числа по 8 бит: 192.168.1.1
Структура: адрес сети + адрес хоста в сети

**Маска подсети** определяет, какая часть адреса относится к сети:
- 255.255.255.0 (/24): первые 24 бита — сеть, последние 8 — хосты (256 адресов)
- 255.255.0.0 (/16): первые 16 бит — сеть (65536 адресов)

**Типы адресов:**
- **Unicast**: один получатель
- **Broadcast**: все устройства в сети (например, 192.168.1.255)
- **Multicast**: группа получателей

**Частные адреса** (RFC 1918), не маршрутизируются в интернете:
- 10.0.0.0/8
- 172.16.0.0/12
- 192.168.0.0/16

**Маршрутизация**: выбор пути для пакета через сеть. Каждый маршрутизатор имеет таблицу маршрутизации и выбирает следующий hop на основе адреса назначения.

**IPv6**: 128-битные адреса (2001:0db8:85a3::8a2e:0370:7334), решающие проблему исчерпания IPv4 адресов.`,
  },
  {
    time: '20:18',
    title: 'Межсетевой уровень: особенности',
    content: `Межсетевой уровень (Network Layer) в TCP/IP имеет ключевые отличия от транспортного:

**Connectionless**: IP не устанавливает соединение. Каждый пакет независим и может идти своим путем.

**Best Effort**: IP не гарантирует доставку, порядок или целостность. Это "постараюсь доставить".

**Фрагментация**: если пакет слишком велик для сети, IP может разбить его на фрагменты.

**No Flow Control**: IP не адаптирует скорость к получателю.

**No Error Correction**: IP обнаруживает ошибки (checksum), но не исправляет их, а просто отбрасывает поврежденные пакеты.

Надежность обеспечивается протоколами верхних уровней (TCP). IP-уровень занимается только адресацией и маршрутизацией.

**Протоколы межсетевого уровня:**
- **IP**: основной протокол для передачи данных
- **ICMP**: служебные сообщения и диагностика
- **IGMP**: управление multicast группами
- **IPsec**: безопасность на уровне IP`,
  },
  {
    time: '20:31',
    title: 'Структура IPv4 пакета',
    content: `IPv4 пакет начинается с заголовка минимум 20 байт (до 60 байт с опциями).

**Основные поля IPv4 заголовка:**

**Version (4 бита)**: версия IP (4 для IPv4)

**IHL (4 бита)**: длина заголовка в 32-битных словах (минимум 5 = 20 байт)

**Type of Service (8 бит)**: приоритет, требования к задержке/пропускной способности

**Total Length (16 бит)**: общая длина пакета с данными (максимум 65535 байт)

**Identification (16 бит)**: уникальный ID для группы фрагментов

**Flags (3 бита)**: управление фрагментацией (DF, MF)

**Fragment Offset (13 бит)**: позиция фрагмента в исходном пакете

**Time to Live (8 бит)**: максимальное число хопов (маршрутизаторов)

**Protocol (8 бит)**: протокол верхнего уровня (6=TCP, 17=UDP, 1=ICMP)

**Header Checksum (16 бит)**: контрольная сумма только заголовка

**Source Address (32 бита)**: IP отправителя

**Destination Address (32 бита)**: IP получателя

**Options**: переменная длина, используются редко

**TTL** уменьшается на 1 на каждом маршрутизаторе. Когда TTL=0, пакет отбрасывается, предотвращая бесконечные петли. Это используется утилитой traceroute.`,
  },
  {
    time: '21:30',
    title: 'TTL и тип протокола',
    content: `**Time To Live (TTL)** — это механизм предотвращения бесконечного блуждания пакетов в сети при наличии маршрутных петель.

Изначально TTL измерялся в секундах, но на практике стал счетчиком хопов. Типичные начальные значения:
- Linux: 64
- Windows: 128
- Cisco: 255

Когда маршрутизатор получает пакет:
1. Уменьшает TTL на 1
2. Пересчитывает контрольную сумму
3. Если TTL=0, отбрасывает пакет и отправляет ICMP Time Exceeded отправителю
4. Иначе пересылает пакет дальше

**Утилита traceroute** использует TTL для определения маршрута:
- Отправляет пакеты с TTL=1, 2, 3...
- Каждый маршрутизатор отвечает ICMP Time Exceeded
- Так определяется полный путь до цели

**Поле Protocol** указывает, какой протокол инкапсулирован в данных IP-пакета:
- 1: ICMP (служебные сообщения)
- 6: TCP
- 17: UDP
- 41: IPv6 (IPv6 over IPv4 туннель)
- 47: GRE (Generic Routing Encapsulation)

Это позволяет принимающей стороне правильно обработать содержимое пакета.`,
  },
  {
    time: '21:59',
    title: 'Фрагментация пакетов',
    content: `Фрагментация возникает, когда IP-пакет слишком велик для передачи по сети и должен быть разбит на части.

**MTU (Maximum Transmission Unit)** — максимальный размер кадра, который может передать канальный уровень:
- Ethernet: 1500 байт
- PPPoE: 1492 байта
- VPN туннели: еще меньше из-за дополнительных заголовков

Если IP-пакет 3000 байт нужно передать через Ethernet (MTU 1500):
1. Пакет разбивается на фрагменты по ~1480 байт данных (20 байт уходит на IP-заголовок)
2. Каждый фрагмент получает один Identification ID
3. Fragment Offset указывает позицию фрагмента в оригинальном пакете
4. Флаг MF (More Fragments) = 1 для всех фрагментов, кроме последнего
5. Получатель собирает фрагменты по ID и Offset

**Проблемы фрагментации:**
- Потеря одного фрагмента требует повторной передачи всех
- Увеличивает нагрузку на маршрутизаторы
- Замедляет передачу

**Path MTU Discovery**: современный метод, где отправитель определяет минимальный MTU на пути и сразу отправляет пакеты подходящего размера, избегая фрагментации.

Флаг **DF (Don't Fragment)** запрещает фрагментацию. Если пакет с DF слишком велик, маршрутизатор отбросит его и отправит ICMP Fragmentation Needed — это основа Path MTU Discovery.`,
  },
  {
    time: '22:59',
    title: 'Флаги фрагментации',
    content: `В IPv4 заголовке есть 3-битное поле флагов, где 2 бита используются для управления фрагментацией:

**Bit 0**: зарезервирован, всегда 0

**Bit 1 - DF (Don't Fragment)**:
- DF=0: разрешена фрагментация
- DF=1: фрагментация запрещена
Если пакет с DF=1 слишком велик, маршрутизатор отбросит его и вернет ICMP "Fragmentation Needed" с указанием MTU.

**Bit 2 - MF (More Fragments)**:
- MF=0: это последний (или единственный) фрагмент
- MF=1: за этим фрагментом следуют еще

**Сценарии:**
- DF=0, MF=0: нефрагментированный пакет (обычный случай)
- DF=0, MF=1: это не последний фрагмент серии
- DF=0, MF=0, Offset>0: это последний фрагмент
- DF=1: фрагментация запрещена

**Практическое применение Path MTU Discovery:**
1. Отправитель устанавливает DF=1
2. Если пакет слишком велик, получает ICMP с реальным MTU
3. Уменьшает размер пакетов
4. Повторяет процесс для всех промежуточных сетей
5. В итоге находит оптимальный размер без фрагментации

Это эффективнее классической фрагментации, так как избегает накладных расходов на разбиение и сборку пакетов.`,
  },
  {
    time: '23:48',
    title: 'Протокол ICMP',
    content: `ICMP (Internet Control Message Protocol) — служебный протокол для передачи диагностической информации и сообщений об ошибках.

**Структура ICMP:**
- Type (8 бит): тип сообщения
- Code (8 бит): подтип в рамках типа
- Checksum (16 бит)
- Данные (зависят от типа)

**Основные типы ICMP:**

**Type 0 - Echo Reply**: ответ на ping

**Type 3 - Destination Unreachable**: хост/сеть/порт недостижим
Code 0: сеть недостижима
Code 1: хост недостижим
Code 3: порт недостижим
Code 4: требуется фрагментация, но установлен DF

**Type 5 - Redirect**: предложение лучшего маршрута

**Type 8 - Echo Request**: запрос ping

**Type 11 - Time Exceeded**: TTL истек (для traceroute)

**Утилита ping**:
- Отправляет ICMP Echo Request (Type 8)
- Ждет Echo Reply (Type 0)
- Измеряет RTT (round-trip time)
- Определяет доступность хоста

**Утилита traceroute/tracert**:
- Отправляет пакеты с возрастающим TTL
- Каждый маршрутизатор отвечает ICMP Time Exceeded
- Определяет весь путь до цели

ICMP не используется приложениями напрямую, но критичен для диагностики и функционирования сети.`,
  },
  {
    time: '25:40',
    title: 'IPv6: новое поколение',
    content: `IPv6 разработан для замены IPv4 из-за исчерпания адресного пространства и имеет существенные улучшения.

**Основные изменения:**

**Адресное пространство**: 128 бит против 32 бит IPv4
- IPv4: ~4.3 миллиарда адресов
- IPv6: 340 ундециллионов адресов (3.4×10³⁸)

**Упрощенный заголовок**: фиксированный размер 40 байт (против переменных 20-60 в IPv4)

**Удалено из заголовка:**
- Фрагментация (переносится в расширения)
- Контрольная сумма заголовка (проверка на уровнях выше/ниже)
- Опции (заменены цепочкой заголовков расширений)

**Новые поля:**
- **Flow Label (20 бит)**: метка потока для QoS, позволяет маршрутизаторам быстро идентифицировать пакеты одного потока
- **Payload Length (16 бит)**: длина полезной нагрузки (без заголовка)
- **Next Header (8 бит)**: тип следующего заголовка (TCP, UDP или расширение)
- **Hop Limit (8 бит)**: аналог TTL

**Встроенная безопасность**: IPsec изначально планировался как обязательный

**Автоконфигурация**: устройства могут автоматически получить IPv6 адрес без DHCP

**Формат адреса**: 2001:0db8:85a3:0000:0000:8a2e:0370:7334
Можно сокращать: 2001:db8:85a3::8a2e:370:7334`,
  },
  {
    time: '26:51',
    title: 'Канальный уровень и Ethernet',
    content: `Канальный уровень в TCP/IP объединяет физический и канальный уровни OSI и отвечает за передачу данных между соседними узлами в сети.

**Ethernet** — доминирующая технология локальных сетей.

**История:**
- 1980: 10 Мбит/с (10BASE5, толстый коаксиал)
- 1985: 10 Мбит/с (10BASE-T, витая пара)
- 1995: 100 Мбит/с (Fast Ethernet)
- 1999: 1000 Мбит/с = 1 Гбит/с (Gigabit Ethernet)
- 2002: 10 Гбит/с
- 2010: 40/100 Гбит/с
- Сейчас: до 400 Гбит/с

**На канальном уровне пакет называется кадр (frame).**

**Функции канального уровня:**
- Добавление MAC-адресов отправителя и получателя
- Обнаружение ошибок (FCS - Frame Check Sequence)
- Управление доступом к среде (кто может передавать)
- Определение границ кадров

**MAC-адрес (Media Access Control)**: 48-битный физический адрес сетевого адаптера
Формат: 00:1A:2B:3C:4D:5E (6 байт в hex)
Первые 3 байта — OUI (Organizationally Unique Identifier), идентификатор производителя.`,
  },
  {
    time: '27:27',
    title: 'Структура Ethernet кадра',
    content: `Ethernet кадр (Frame) имеет следующую структуру:

**Преамбула (8 байт)**:
- 7 байт: 10101010... (синхронизация приемника)
- 1 байт SFD (Start Frame Delimiter): 10101011 (начало кадра)

**Заголовок (14 байт):**
- Destination MAC (6 байт): адрес получателя
- Source MAC (6 байт): адрес отправителя
- EtherType (2 байта): тип протокола верхнего уровня
  0x0800 = IPv4
  0x86DD = IPv6
  0x0806 = ARP

**Payload (46-1500 байт)**:
- Минимум 46 байт (дополняется padding если меньше)
- Максимум 1500 байт (MTU Ethernet)
- Содержит IP-пакет

**Frame Check Sequence - FCS (4 байта)**:
- 32-битная CRC (Cyclic Redundancy Check)
- Проверка целостности кадра
- Вычисляется отправителем, проверяется получателем
- Ошибочные кадры отбрасываются

**Jumbo Frames**: некоторые сети поддерживают кадры до 9000 байт для повышения эффективности при передаче больших объемов данных.

**Полный размер кадра**: 64-1518 байт (без преамбулы)
Меньше 64 байт — runt (ошибка)
Больше 1518 байт — giant (ошибка, если не включены Jumbo Frames)`,
  },
  {
    time: '28:44',
    title: 'Физический уровень',
    content: `Физический уровень преобразует цифровые данные (биты) в физические сигналы и обратно.

**Среды передачи:**

**Медные кабели:**
- **Коаксиальный кабель** (устарел): центральный проводник + оплетка, 10 Мбит/с
- **Витая пара (Twisted Pair)**: 8 проводов, скрученных парами для снижения помех
  UTP (Unshielded): без экранирования, категории Cat5e, Cat6, Cat6a, Cat7
  Cat5e: до 1 Гбит/с на 100м
  Cat6: до 10 Гбит/с на 55м
  Cat6a: до 10 Гбит/с на 100м

**Оптоволокно:**
- Стеклянное/пластиковое волокно передает световые импульсы
- Иммунитет к электромагнитным помехам
- Большие расстояния (километры без усиления)
- Высокие скорости (до 400 Гбит/с и выше)
- Типы: одномодовое (Single-Mode) для больших расстояний, многомодовое (Multi-Mode) для коротких

**Беспроводные среды:**
- Wi-Fi (IEEE 802.11): радиоволны 2.4/5/6 ГГц
- Bluetooth: короткие расстояния
- LTE/5G: сотовые сети

**Кодирование сигналов:**
- NRZ (Non-Return to Zero)
- Manchester: каждый бит кодируется переходом сигнала
- 4B/5B: эффективность + синхронизация

**Синхронизация**: получатель должен знать, когда начинается и заканчивается каждый бит. Используются специальные последовательности (преамбула) и кодирование.`,
  },
  {
    time: '29:36',
    title: 'Типы кабелей подробно',
    content: `**Коаксиальный кабель** (10BASE5, 10BASE2):
- Центральный медный проводник
- Диэлектрическая изоляция
- Металлическая оплетка (экран)
- Внешняя изоляция
- Топология: общая шина
- Проблемы: низкая скорость, одна точка отказа, сложный монтаж
- Сейчас используется в кабельном ТВ и некоторых промышленных системах

**Витая пара:**
- 8 проводов, организованных в 4 пары
- Каждая пара скручена с разным шагом
- Скрутка снижает электромагнитные помехи и перекрестные наводки

**Типы по дуплексности:**
- **Half-Duplex**: 2 пары (1 TX, 1 RX), передача в одну сторону в момент времени
- **Full-Duplex**: 4 пары, одновременная передача в обе стороны, удвоение скорости

**Распиновка (T568B):**
Пара 1 (оранжевая): пины 1, 2
Пара 2 (зеленая): пины 3, 6
Пара 3 (синяя): пины 4, 5
Пара 4 (коричневая): пины 7, 8

**10/100 Мбит/с**: используются только 2 пары (1 и 2)
**1000 Мбит/с**: используются все 4 пары

**Оптоволокно:**
- Сердцевина (core): 9 или 50/62.5 мкм
- Оболочка (cladding): обеспечивает полное внутреннее отражение
- Буфер и защитная оболочка

**Преимущества оптики:**
- Нет электромагнитных помех
- Невозможно прослушивание без физического доступа (безопасность)
- Большие расстояния без повторителей
- Высокие скорости

**Недостатки:**
- Дороже
- Сложнее монтаж (требуется сварка/коннекторизация)
- Хрупкость (минимальный радиус изгиба)`,
  },
  {
    time: '30:27',
    title: 'Коммутация и маршрутизация',
    content: `**Коммутатор (Switch)** — устройство канального уровня (L2):
- Работает с MAC-адресами
- Каждый порт — отдельный collision domain
- Изучает MAC-адреса устройств (таблица MAC-адресов)
- Пересылает кадры только на нужный порт (unicast) или всем (broadcast)
- Не изменяет кадры

**Принцип работы:**
1. Кадр приходит на порт
2. Switch запоминает source MAC → порт
3. Смотрит destination MAC в таблице
4. Если найден — пересылает на конкретный порт
5. Если не найден — flooding (на все порты кроме входящего)

**Маршрутизатор (Router)** — устройство сетевого уровня (L3):
- Работает с IP-адресами
- Соединяет разные сети/подсети
- Принимает решения на основе таблицы маршрутизации
- Уменьшает TTL
- Может фрагментировать пакеты
- Изменяет заголовки (TTL, checksum)

**Таблица маршрутизации** содержит:
- Сеть назначения (destination network)
- Маска подсети
- Следующий hop (next-hop)
- Метрика (расстояние до сети)
- Исходящий интерфейс

**Протоколы маршрутизации:**
- **Static**: ручная настройка маршрутов
- **RIP** (Routing Information Protocol): distance-vector, метрика — количество хопов
- **OSPF** (Open Shortest Path First): link-state, метрика — cost
- **BGP** (Border Gateway Protocol): для маршрутизации между автономными системами в интернете

**L3 Switch** (многоуровневый коммутатор): комбинирует функции switch и router, выполняет маршрутизацию на аппаратном уровне для высокой производительности.`,
  },
]

